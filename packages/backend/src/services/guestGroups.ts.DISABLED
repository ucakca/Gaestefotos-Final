/**
 * Guest Groups Service
 * 
 * Verwaltung von Gästegruppen für Events
 */

import prisma from '../config/database';
import { logger } from '../utils/logger';
import { invalidateGuestCache } from '../utils/cacheInvalidation';

export interface CreateGuestGroupData {
  name: string;
  description?: string;
  color?: string;
}

export interface UpdateGuestGroupData {
  name?: string;
  description?: string | null;
  color?: string;
  order?: number;
}

/**
 * Get all guest groups for an event
 */
export async function getGuestGroups(eventId: string) {
  try {
    const groups = await prisma.guestGroup.findMany({
      where: { eventId },
      include: {
        _count: {
          select: { guests: true },
        },
      },
      orderBy: { order: 'asc' },
    });

    return groups;
  } catch (error) {
    logger.error('[GuestGroups] Failed to fetch groups', {
      eventId,
      error: (error as Error).message,
    });
    throw error;
  }
}

/**
 * Get single guest group
 */
export async function getGuestGroup(groupId: string) {
  try {
    const group = await prisma.guestGroup.findUnique({
      where: { id: groupId },
      include: {
        guests: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            status: true,
          },
          orderBy: { lastName: 'asc' },
        },
        _count: {
          select: { guests: true },
        },
      },
    });

    return group;
  } catch (error) {
    logger.error('[GuestGroups] Failed to fetch group', {
      groupId,
      error: (error as Error).message,
    });
    throw error;
  }
}

/**
 * Create guest group
 */
export async function createGuestGroup(eventId: string, data: CreateGuestGroupData) {
  try {
    // Get current max order
    const maxOrder = await prisma.guestGroup.findFirst({
      where: { eventId },
      orderBy: { order: 'desc' },
      select: { order: true },
    });

    const group = await prisma.guestGroup.create({
      data: {
        eventId,
        name: data.name,
        description: data.description,
        color: data.color || generateRandomColor(),
        order: (maxOrder?.order || 0) + 1,
      },
      include: {
        _count: {
          select: { guests: true },
        },
      },
    });

    await invalidateGuestCache(eventId);

    logger.info('[GuestGroups] Group created', {
      eventId,
      groupId: group.id,
      name: group.name,
    });

    return group;
  } catch (error) {
    logger.error('[GuestGroups] Failed to create group', {
      eventId,
      error: (error as Error).message,
    });
    throw error;
  }
}

/**
 * Update guest group
 */
export async function updateGuestGroup(groupId: string, data: UpdateGuestGroupData) {
  try {
    const group = await prisma.guestGroup.update({
      where: { id: groupId },
      data,
      include: {
        _count: {
          select: { guests: true },
        },
      },
    });

    await invalidateGuestCache(group.eventId);

    logger.info('[GuestGroups] Group updated', {
      groupId,
      updates: Object.keys(data),
    });

    return group;
  } catch (error) {
    logger.error('[GuestGroups] Failed to update group', {
      groupId,
      error: (error as Error).message,
    });
    throw error;
  }
}

/**
 * Delete guest group
 */
export async function deleteGuestGroup(groupId: string) {
  try {
    const group = await prisma.guestGroup.delete({
      where: { id: groupId },
    });

    await invalidateGuestCache(group.eventId);

    logger.info('[GuestGroups] Group deleted', { groupId });

    return group;
  } catch (error) {
    logger.error('[GuestGroups] Failed to delete group', {
      groupId,
      error: (error as Error).message,
    });
    throw error;
  }
}

/**
 * Assign guest to group
 */
export async function assignGuestToGroup(guestId: string, groupId: string | null) {
  try {
    const guest = await prisma.guest.update({
      where: { id: guestId },
      data: { groupId },
      include: {
        group: true,
      },
    });

    await invalidateGuestCache(guest.eventId);

    logger.info('[GuestGroups] Guest assigned', {
      guestId,
      groupId,
    });

    return guest;
  } catch (error) {
    logger.error('[GuestGroups] Failed to assign guest', {
      guestId,
      groupId,
      error: (error as Error).message,
    });
    throw error;
  }
}

/**
 * Bulk assign guests to group
 */
export async function bulkAssignGuests(guestIds: string[], groupId: string | null) {
  try {
    const result = await prisma.guest.updateMany({
      where: {
        id: { in: guestIds },
      },
      data: { groupId },
    });

    // Invalidate cache for all affected events
    const guests = await prisma.guest.findMany({
      where: { id: { in: guestIds } },
      select: { eventId: true },
      distinct: ['eventId'],
    });

    for (const guest of guests) {
      await invalidateGuestCache(guest.eventId);
    }

    logger.info('[GuestGroups] Bulk assignment completed', {
      count: result.count,
      groupId,
    });

    return result;
  } catch (error) {
    logger.error('[GuestGroups] Failed bulk assignment', {
      error: (error as Error).message,
    });
    throw error;
  }
}

/**
 * Reorder guest groups
 */
export async function reorderGuestGroups(eventId: string, groupOrders: Array<{ id: string; order: number }>) {
  try {
    const updates = groupOrders.map((item) =>
      prisma.guestGroup.update({
        where: { id: item.id },
        data: { order: item.order },
      })
    );

    await prisma.$transaction(updates);

    await invalidateGuestCache(eventId);

    logger.info('[GuestGroups] Groups reordered', {
      eventId,
      count: groupOrders.length,
    });

    return true;
  } catch (error) {
    logger.error('[GuestGroups] Failed to reorder groups', {
      eventId,
      error: (error as Error).message,
    });
    throw error;
  }
}

/**
 * Generate random color for group
 */
function generateRandomColor(): string {
  const colors = [
    '#ef4444', // red
    '#f59e0b', // amber
    '#10b981', // emerald
    '#3b82f6', // blue
    '#8b5cf6', // violet
    '#ec4899', // pink
    '#14b8a6', // teal
    '#f97316', // orange
  ];
  
  return colors[Math.floor(Math.random() * colors.length)];
}
