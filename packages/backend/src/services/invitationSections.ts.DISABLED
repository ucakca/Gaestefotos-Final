/**
 * Invitation Sections Service
 * 
 * Verwaltung von dynamischen Einladungs-Sektionen
 */

import prisma from '../config/database';
import { logger } from '../utils/logger';
import { SectionType } from '@prisma/client';

export interface CreateSectionData {
  type: SectionType;
  title?: string;
  content?: any;
  groupIds?: string[];
}

export interface UpdateSectionData {
  type?: SectionType;
  title?: string;
  content?: any;
  order?: number;
  isVisible?: boolean;
  groupIds?: string[];
}

/**
 * Get all sections for an invitation
 */
export async function getInvitationSections(invitationId: string) {
  try {
    const sections = await prisma.invitationSection.findMany({
      where: { invitationId },
      include: {
        groupAccess: {
          include: {
            group: {
              select: {
                id: true,
                name: true,
                color: true,
              },
            },
          },
        },
      },
      orderBy: { order: 'asc' },
    });

    return sections;
  } catch (error) {
    logger.error('[InvitationSections] Failed to fetch sections', {
      invitationId,
      error: (error as Error).message,
    });
    throw error;
  }
}

/**
 * Get sections visible to a specific guest
 */
export async function getSectionsForGuest(invitationId: string, guestId?: string) {
  try {
    let groupId: string | null = null;

    if (guestId) {
      const guest = await prisma.guest.findUnique({
        where: { id: guestId },
        select: { groupId: true },
      });
      groupId = guest?.groupId || null;
    }

    const sections = await prisma.invitationSection.findMany({
      where: {
        invitationId,
        isVisible: true,
        OR: [
          // Public sections (no group access restrictions)
          { groupAccess: { none: {} } },
          // Group-specific sections
          ...(groupId ? [{ groupAccess: { some: { groupId } } }] : []),
        ],
      },
      select: {
        id: true,
        type: true,
        title: true,
        content: true,
        order: true,
      },
      orderBy: { order: 'asc' },
    });

    return sections;
  } catch (error) {
    logger.error('[InvitationSections] Failed to fetch sections for guest', {
      invitationId,
      guestId,
      error: (error as Error).message,
    });
    throw error;
  }
}

/**
 * Create section
 */
export async function createSection(invitationId: string, data: CreateSectionData) {
  try {
    // Get current max order
    const maxOrder = await prisma.invitationSection.findFirst({
      where: { invitationId },
      orderBy: { order: 'desc' },
      select: { order: true },
    });

    const section = await prisma.invitationSection.create({
      data: {
        invitationId,
        type: data.type,
        title: data.title,
        content: data.content,
        order: (maxOrder?.order || 0) + 1,
        groupAccess: data.groupIds
          ? {
              create: data.groupIds.map((groupId) => ({ groupId })),
            }
          : undefined,
      },
      include: {
        groupAccess: {
          include: {
            group: {
              select: {
                id: true,
                name: true,
                color: true,
              },
            },
          },
        },
      },
    });

    logger.info('[InvitationSections] Section created', {
      invitationId,
      sectionId: section.id,
      type: section.type,
    });

    return section;
  } catch (error) {
    logger.error('[InvitationSections] Failed to create section', {
      invitationId,
      error: (error as Error).message,
    });
    throw error;
  }
}

/**
 * Update section
 */
export async function updateSection(sectionId: string, data: UpdateSectionData) {
  try {
    // Update section
    const section = await prisma.invitationSection.update({
      where: { id: sectionId },
      data: {
        type: data.type,
        title: data.title,
        content: data.content,
        order: data.order,
        isVisible: data.isVisible,
      },
    });

    // Update group access if provided
    if (data.groupIds !== undefined) {
      // Delete existing
      await prisma.sectionGroupAccess.deleteMany({
        where: { sectionId },
      });

      // Create new
      if (data.groupIds.length > 0) {
        await prisma.sectionGroupAccess.createMany({
          data: data.groupIds.map((groupId) => ({
            sectionId,
            groupId,
          })),
        });
      }
    }

    // Fetch updated section
    const updatedSection = await prisma.invitationSection.findUnique({
      where: { id: sectionId },
      include: {
        groupAccess: {
          include: {
            group: {
              select: {
                id: true,
                name: true,
                color: true,
              },
            },
          },
        },
      },
    });

    logger.info('[InvitationSections] Section updated', {
      sectionId,
      updates: Object.keys(data),
    });

    return updatedSection;
  } catch (error) {
    logger.error('[InvitationSections] Failed to update section', {
      sectionId,
      error: (error as Error).message,
    });
    throw error;
  }
}

/**
 * Delete section
 */
export async function deleteSection(sectionId: string) {
  try {
    const section = await prisma.invitationSection.delete({
      where: { id: sectionId },
    });

    logger.info('[InvitationSections] Section deleted', { sectionId });

    return section;
  } catch (error) {
    logger.error('[InvitationSections] Failed to delete section', {
      sectionId,
      error: (error as Error).message,
    });
    throw error;
  }
}

/**
 * Reorder sections
 */
export async function reorderSections(
  invitationId: string,
  sectionOrders: Array<{ id: string; order: number }>
) {
  try {
    const updates = sectionOrders.map((item) =>
      prisma.invitationSection.update({
        where: { id: item.id },
        data: { order: item.order },
      })
    );

    await prisma.$transaction(updates);

    logger.info('[InvitationSections] Sections reordered', {
      invitationId,
      count: sectionOrders.length,
    });

    return true;
  } catch (error) {
    logger.error('[InvitationSections] Failed to reorder sections', {
      invitationId,
      error: (error as Error).message,
    });
    throw error;
  }
}

/**
 * Duplicate section
 */
export async function duplicateSection(sectionId: string) {
  try {
    const original = await prisma.invitationSection.findUnique({
      where: { id: sectionId },
      include: {
        groupAccess: true,
      },
    });

    if (!original) {
      throw new Error('Section not found');
    }

    // Get max order
    const maxOrder = await prisma.invitationSection.findFirst({
      where: { invitationId: original.invitationId },
      orderBy: { order: 'desc' },
      select: { order: true },
    });

    const duplicate = await prisma.invitationSection.create({
      data: {
        invitationId: original.invitationId,
        type: original.type,
        title: `${original.title} (Kopie)`,
        content: original.content as any,
        order: (maxOrder?.order || 0) + 1,
        isVisible: original.isVisible,
        groupAccess: {
          create: original.groupAccess.map((access) => ({
            groupId: access.groupId,
          })),
        },
      },
      include: {
        groupAccess: {
          include: {
            group: {
              select: {
                id: true,
                name: true,
                color: true,
              },
            },
          },
        },
      },
    });

    logger.info('[InvitationSections] Section duplicated', {
      originalId: sectionId,
      duplicateId: duplicate.id,
    });

    return duplicate;
  } catch (error) {
    logger.error('[InvitationSections] Failed to duplicate section', {
      sectionId,
      error: (error as Error).message,
    });
    throw error;
  }
}
